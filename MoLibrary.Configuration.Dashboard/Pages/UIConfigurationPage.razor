@page "/configuration-manage"
@using MoLibrary.Configuration.Dashboard.UIConfiguration.Components
@using MoLibrary.Configuration.Dashboard.UIConfiguration.Services
@using MoLibrary.Configuration.Dashboard.UIConfiguration.Models
@using MudBlazor
@inject ConfigurationService ConfigurationService
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<PageTitle>@_pageTitle</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge">
    <MudText Typo="Typo.h3" GutterBottom="true">
        <MudIcon Icon="@Icons.Material.Filled.Settings" Class="mr-3" />
        配置管理
    </MudText>

    <MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6">
        <MudTabPanel Text="配置列表" Icon="@Icons.Material.Filled.List">
            <ConfigurationList @ref="_configurationList" 
                             OnEditRequested="HandleEditRequested"
                             OnHistoryRequested="HandleHistoryRequested"
                             OnDeleteRequested="HandleDeleteRequested" />
        </MudTabPanel>

        <MudTabPanel Text="配置历史" Icon="@Icons.Material.Filled.History">
            <ConfigurationHistory @ref="_configurationHistory" />
        </MudTabPanel>

        <MudTabPanel Text="实时监控" Icon="@Icons.Material.Filled.MonitorHeart">
            <ConfigurationStatus @ref="_configurationStatus" />
        </MudTabPanel>
    </MudTabs>

    <!-- 编辑对话框 -->
    <ConfigurationEditor @ref="_configurationEditor" 
                        OnConfigurationUpdated="HandleConfigurationUpdated" />

</MudContainer>

@code {
    public const string CONFIGURATION_DEBUG_URL = "/configuration-manage";

    private string _pageTitle = "配置管理";
    private ConfigurationList? _configurationList;
    private ConfigurationHistory? _configurationHistory;
    private ConfigurationStatus? _configurationStatus;
    private ConfigurationEditor? _configurationEditor;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // 在首次渲染后初始化数据
            await LoadInitialData();
            StateHasChanged();
        }
    }

    private async Task LoadInitialData()
    {
        try
        {
            // 初始化各个组件的数据
            if (_configurationList != null)
            {
                await _configurationList.LoadDataAsync();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"初始化数据失败: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleEditRequested(ConfigurationItemViewModel config)
    {
        if (_configurationEditor != null)
        {
            await _configurationEditor.ShowEditDialogAsync(config);
        }
    }

    private async Task HandleHistoryRequested(ConfigurationItemViewModel config)
    {
        if (_configurationHistory != null)
        {
            await _configurationHistory.LoadHistoryForConfigAsync(config.Key, config.AppId);
        }
    }

    private async Task HandleDeleteRequested(ConfigurationItemViewModel config)
    {
        var parameters = new DialogParameters<MudMessageBox>
        {
            { x => x.Title, "确认删除" },
            { x => x.Message, $"确定要删除配置项 '{config.Key}' 吗？此操作不可撤销！" },
            { x => x.CancelText, "取消" },
            { x => x.YesText, "删除" }
        };

        var dialog = Snackbar.Configuration.SnackbarVariant == Variant.Filled 
            ? DialogService.Show<MudMessageBox>("", parameters)
            : DialogService.Show<MudMessageBox>("", parameters);

        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            await DeleteConfigurationAsync(config);
        }
    }

    private async Task HandleConfigurationUpdated(ConfigurationItemViewModel config)
    {
        // 配置更新后刷新列表
        if (_configurationList != null)
        {
            await _configurationList.RefreshDataAsync();
        }

        Snackbar.Add($"配置项 '{config.Key}' 更新成功", Severity.Success);
    }

    private async Task DeleteConfigurationAsync(ConfigurationItemViewModel config)
    {
        try
        {
            // 这里应该调用删除API，但由于原始代码中没有删除功能，我们暂时只显示消息
            await Task.Delay(500); // 模拟API调用

            Snackbar.Add($"配置项 '{config.Key}' 删除成功", Severity.Success);

            if (_configurationList != null)
            {
                await _configurationList.RefreshDataAsync();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"删除配置失败: {ex.Message}", Severity.Error);
        }
    }
}