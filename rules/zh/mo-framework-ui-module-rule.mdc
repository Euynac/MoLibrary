---
description: 使用MoFramework构建UI模块的规则和指南
globs: *.cs,*.razor
alwaysApply: false
---

# 变量定义

> 变量代表特定上下文的参数，用 `$` 包围。

- `$ModuleName$` - 代表模块名称，必须使用PascalCase。
- `$ModuleUIName$` - UI模块名称，格式为 `$ModuleName$UI`。
- `$UIFolderName$` - UI文件夹名称，格式为 `UI$ModuleName$`。
- `$PageName$` - 页面名称，格式为 `UI$ModuleName$Page`。
- `$RouteURL$` - 页面路由URL，必须使用kebab-case，格式建议为 `/$module-name$-debug` 或 `/$module-name$-manage`。

# MoFramework UI模块规则

## 1. 模块文件结构

### 1.1 创建UI模块类文件
- 文件位置：`MoLibrary.FrameworkUI/Modules/$ModuleUIName$.cs`
- 文件命名：以模块名+UI的格式命名，如 `SignalrUI.cs`
- 类命名：`Module$ModuleUIName$`

### 1.2 创建UI模块文件夹
- 文件夹位置：`MoLibrary.FrameworkUI/$UIFolderName$/`
- 文件夹命名：UI+模块名，如 `UISignalr`
- 子文件夹结构：
  ```
  UI$ModuleName$/
  ├── Components/     # Blazor组件
  ├── Models/         # 数据模型
  └── Services/       # 业务服务
  ```

### 1.3 创建页面文件
- 文件位置：`MoLibrary.FrameworkUI/Pages/$PageName$.razor`
- 文件命名：UI+模块名+Page，如 `UISignalRPage.razor`

## 2. 代码结构规范

### 2.1 UI模块类实现
```csharp
public class Module$ModuleUIName$(Module$ModuleUIName$Option option)
    : MoModuleWithDependencies<Module$ModuleUIName$, Module$ModuleUIName$Option, Module$ModuleUIName$Guide>(option)
{
    public override EMoModules CurModuleEnum()
    {
        return EMoModules.$ModuleUIName$;
    }

    public override void ConfigureServices(IServiceCollection services)
    {
        // 注册相关服务
        services.AddScoped<$ModuleName$DebugService>();
    }

    public override void ClaimDependencies()
    {
        if (!Option.Disable$ModuleName$Page)
        {
            DependsOnModule<Module$ModuleName$Guide>().Register();
            DependsOnModule<ModuleUICoreGuide>().Register()
                .RegisterUIComponents(p => p.RegisterComponent<$PageName$>(
                    $PageName$.$ModuleName$_DEBUG_URL, 
                    "$ModuleName$调试", 
                    Icons.Material.Filled.Settings, 
                    "系统管理", 
                    addToNav: true, 
                    navOrder: 100));
        }
    }
}
```

### 2.2 页面路由定义
```csharp
@attribute [Route($ModuleName$_DEBUG_URL)]

@code {
    public const string $ModuleName$_DEBUG_URL = "/$route-url$";
}
```

### 2.3 页面依赖注入
```csharp
@using MoLibrary.FrameworkUI.$UIFolderName$.Components
@using MoLibrary.FrameworkUI.$UIFolderName$.Services
@using MoLibrary.FrameworkUI.$UIFolderName$.Models
@inject $ModuleName$DebugService $ModuleName$DebugService
```

## 3. 模块化开发要求

### 3.1 组件拆分原则
- **单一职责**：每个组件只负责一个特定功能
- **可复用性**：通用功能抽离为独立组件
- **参数化**：通过参数控制组件行为和显示

### 3.2 组件命名规范
- 组件文件放在 `$UIFolderName$/Components/` 目录下
- 命名格式：`$ModuleName$$FunctionName$.razor`
- 示例：`SignalRConnectionConfig.razor`、`SignalRMessageLog.razor`

### 3.3 服务抽象原则
- 业务逻辑抽离到Service层
- Service文件放在 `$UIFolderName$/Services/` 目录下  
- 命名格式：`$ModuleName$DebugService.cs`或`$ModuleName$ManageService.cs`
- 通过依赖注入使用服务

### 3.4 数据模型管理
- 页面相关的数据模型放在 `$UIFolderName$/Models/` 目录下
- 使用强类型模型，避免动态类型
- 模型命名要清晰表达其用途

## 4. 开发最佳实践

### 4.1 代码复用
- 相似功能的组件要抽象出公共基类或接口
- 通用的UI交互逻辑封装成可复用的服务
- 统一的样式和主题使用MudBlazor组件库

### 4.2 性能优化
- 大组件拆分为小组件，减少重渲染范围
- 使用`@key`指令优化列表渲染
- 避免在模板中进行复杂计算

### 4.3 错误处理
- 实现统一的错误处理机制
- 使用ISnackbar显示用户友好的错误信息
- 记录详细的调试日志

## 5. 示例参考

以UISignalR模块为例：
- 模块文件：`Modules/SignalrUI.cs`
- UI文件夹：`UISignalr/`
- 页面文件：`Pages/UISignalRPage.razor`
- 组件：`UISignalr/Components/SignalRConnectionConfig.razor`等
- 服务：`UISignalr/Services/SignalRDebugService.cs`
