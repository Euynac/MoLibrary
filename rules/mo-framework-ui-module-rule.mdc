---
description: 使用MoFramework构建UI模块的规则和指南
globs: *.cs,*.razor
alwaysApply: false
---

# 变量定义

> 变量代表特定上下文的参数，用 `$` 包围。

- `$ModuleName$` - 代表模块名称，必须使用PascalCase。
- `$ModuleUIName$` - UI模块名称，格式为 `$ModuleName$UI`。
- `$UIFolderName$` - UI文件夹名称，格式为 `UI$ModuleName$`。
- `$PageName$` - 页面名称，格式为 `UI$ModuleName$Page`。
- `$RouteURL$` - 页面路由URL，必须使用kebab-case，格式建议为 `/$module-name$-debug` 或 `/$module-name$-manage`。

# MoFramework UI模块规则

## 1. 模块文件结构

### 1.1 创建UI模块类文件
- 文件位置：`MoLibrary.FrameworkUI/Modules/$ModuleUIName$.cs`
- 文件命名：以模块名+UI的格式命名，如 `SignalrUI.cs`
- 类命名：`Module$ModuleUIName$`

### 1.2 创建UI模块文件夹
- 文件夹位置：`MoLibrary.FrameworkUI/$UIFolderName$/`
- 文件夹命名：UI+模块名，如 `UISignalr`
- 子文件夹结构：
  ```
  UI$ModuleName$/
  ├── Components/     # Blazor组件
  ├── Models/         # 数据模型
  └── Services/       # 业务服务
  ```

### 1.3 创建页面文件
- 文件位置：`MoLibrary.FrameworkUI/Pages/$PageName$.razor`
- 文件命名：UI+模块名+Page，如 `UISignalRPage.razor`

## 2. 代码结构规范

### 2.1 UI模块类实现
```csharp
public class Module$ModuleUIName$(Module$ModuleUIName$Option option)
    : MoModuleWithDependencies<Module$ModuleUIName$, Module$ModuleUIName$Option, Module$ModuleUIName$Guide>(option)
{
    public override EMoModules CurModuleEnum()
    {
        return EMoModules.$ModuleUIName$;
    }

    public override void ConfigureServices(IServiceCollection services)
    {
        // 注册相关服务
        services.AddScoped<$ModuleName$DebugService>();
    }

    public override void ClaimDependencies()
    {
        if (!Option.Disable$ModuleName$Page)
        {
            DependsOnModule<Module$ModuleName$Guide>().Register();
            DependsOnModule<ModuleUICoreGuide>().Register()
                .RegisterUIComponents(p => p.RegisterComponent<$PageName$>(
                    $PageName$.$ModuleName$_DEBUG_URL, 
                    "$ModuleName$调试", 
                    Icons.Material.Filled.Settings, 
                    "系统管理", 
                    addToNav: true, 
                    navOrder: 100));
        }
    }
}
```

### 2.2 页面路由定义
```csharp
@attribute [Route($ModuleName$_DEBUG_URL)]

@code {
    public const string $ModuleName$_DEBUG_URL = "/$route-url$";
}
```

### 2.3 页面依赖注入
```csharp
@using MoLibrary.FrameworkUI.$UIFolderName$.Components
@using MoLibrary.FrameworkUI.$UIFolderName$.Services
@using MoLibrary.FrameworkUI.$UIFolderName$.Models
@inject $ModuleName$DebugService $ModuleName$DebugService
```

## 3. 模块化开发要求

### 3.1 组件拆分原则
- **单一职责**：每个组件只负责一个特定功能
- **可复用性**：通用功能抽离为独立组件
- **参数化**：通过参数控制组件行为和显示

### 3.2 组件命名规范
- 组件文件放在 `$UIFolderName$/Components/` 目录下
- 命名格式：`$ModuleName$$FunctionName$.razor`
- 示例：`SignalRConnectionConfig.razor`、`SignalRMessageLog.razor`

### 3.3 服务抽象原则
- 业务逻辑抽离到Service层
- Service文件放在 `$UIFolderName$/Services/` 目录下  
- 命名格式：`$ModuleName$DebugService.cs`或`$ModuleName$ManageService.cs`
- 通过依赖注入使用服务

### 3.4 数据模型管理
- 页面相关的数据模型放在 `$UIFolderName$/Models/` 目录下
- 使用强类型模型，避免动态类型
- 模型命名要清晰表达其用途

## 4. 开发最佳实践

### 4.1 代码复用
- 相似功能的组件要抽象出公共基类或接口
- 通用的UI交互逻辑封装成可复用的服务
- 统一的样式和主题使用MudBlazor组件库

### 4.2 性能优化
- 大组件拆分为小组件，减少重渲染范围
- 使用`@key`指令优化列表渲染
- 避免在模板中进行复杂计算

### 4.3 错误处理
- 实现统一的错误处理机制
- 使用ISnackbar显示用户友好的错误信息
- 记录详细的调试日志

## 5. Controller集成模式

### 5.1 Controller开发规范
当需要为UI模块提供API支持时，应遵循以下模式：

#### 5.1.1 Controller位置和命名
- Controller文件位置：`$UIFolderName$/Controllers/Module$ModuleName$Controller.cs`
- Controller命名：`Module$ModuleName$Controller`
- 继承：`MoModuleControllerBase`
- 特性：`[ApiController]`

#### 5.1.2 模块选项配置
UI模块选项必须继承`MoModuleControllerOption`：
```csharp
public class Module$ModuleName$UIOption : MoModuleControllerOption<Module$ModuleName$UI>
{ 
    public bool DisableUI$ModuleName$Page { get; set; }
}
```

#### 5.1.3 Controller注册
在模块的`ClaimDependencies`方法中注册Controller：
```csharp
public override void ClaimDependencies()
{
    if (!Option.DisableUI$ModuleName$Page)
    {
        // 注册Controller依赖
        DependsOnModule<ModuleControllersGuide>().Register()
            .RegisterMoControllers<Module$ModuleName$Controller>(Option);
        
        // 其他依赖注册...
    }
}
```

#### 5.1.4 Controller实现示例
```csharp
[ApiController]
public class Module$ModuleName$Controller : MoModuleControllerBase
{
    [HttpGet("endpoint")]
    public IActionResult GetData()
    {
        try
        {
            var data = // 获取数据逻辑
            return Res.Ok(data).GetResponse(this);
        }
        catch (Exception ex)
        {
            return Res.Fail($"操作失败: {ex.Message}").GetResponse(this);
        }
    }
}
```

#### 5.1.5 响应类型规范
- 必须使用`Res<T>`或`Res`类型作为返回值
- 引用`MoLibrary.Core.Extensions`中的`RESTfulApiExtensions`
- 使用`.GetResponse(this)`方法进行响应封装

### 5.2 调用Controller的服务模式

#### 5.2.1 服务文件位置
- 服务文件：`$UIFolderName$/Services/$ModuleName$Service.cs`
- 用途：封装对自身Controller的HTTP调用

#### 5.2.2 服务实现模式

根据Controller来源的不同，有两种URL获取方式：

**方式一：UI模块自身的Controller**
```csharp
public class $ModuleName$Service
{
    private readonly HttpClient _httpClient;
    private readonly NavigationManager _navigationManager;
    private readonly Module$ModuleName$UIOption _option;

    public $ModuleName$Service(HttpClient httpClient, NavigationManager navigationManager, IOptions<Module$ModuleName$UIOption> option)
    {
        _httpClient = httpClient;
        _navigationManager = navigationManager;
        _option = option.Value;
    }

    public async Task<TResponse?> CallApiAsync()
    {
        // 使用Option的GetRoute方法获取完整路由
        var controllerRoute = _option.GetRoute<Module$ModuleName$Controller>("endpoint");
        var baseUri = _navigationManager.BaseUri.TrimEnd('/');
        var url = $"{baseUri}/{controllerRoute.TrimStart('/')}";
        
        var response = await _httpClient.GetAsync(url);
        // 处理响应...
    }
}
```

**方式二：其他模块的Controller**
```csharp
public class $ModuleName$Service
{
    private readonly HttpClient _httpClient;
    private readonly NavigationManager _navigationManager;
    private readonly ModuleOtherOption _otherOption;

    public $ModuleName$Service(HttpClient httpClient, NavigationManager navigationManager, IOptions<ModuleOtherOption> otherOption)
    {
        _httpClient = httpClient;
        _navigationManager = navigationManager;
        _otherOption = otherOption.Value;
    }

    public async Task<TResponse?> CallApiAsync()
    {
        // 使用其他模块Option的GetControllerRouteTemplate方法
        var controllerRoute = _otherOption.GetControllerRouteTemplate<ModuleOtherController>();
        var baseUri = _navigationManager.BaseUri.TrimEnd('/');
        var url = $"{baseUri}/{controllerRoute.TrimStart('/')}/endpoint";
        
        var response = await _httpClient.GetAsync(url);
        // 处理响应...
    }
}
```

#### 5.2.3 依赖注入配置
在模块的`ConfigureServices`方法中注册服务：
```csharp
public override void ConfigureServices(IServiceCollection services)
{
    services.AddScoped<$ModuleName$Service>();
}
```

### 5.3 数据模型管理
- 响应模型位置：`$UIFolderName$/Models/`
- 命名约定：`$ModuleName$Response`、`$ModuleName$Request`等
- 与Controller返回的数据结构保持一致

## 6. 示例参考

以UISignalR模块为例：
- 模块文件：`Modules/SignalrUI.cs`
- UI文件夹：`UISignalr/`
- 页面文件：`Pages/UISignalRPage.razor`
- 组件：`UISignalr/Components/SignalRConnectionConfig.razor`等
- 服务：`UISignalr/Services/SignalRDebugService.cs`

以UISystemInfo模块为例（带Controller集成）：
- 模块文件：`Modules/SystemInfoUI.cs`
- UI文件夹：`UISystemInfo/`
- 页面文件：`Pages/UISystemInfoPage.razor`
- Controller：`UISystemInfo/Controllers/ModuleSystemInfoController.cs`
- 服务：`UISystemInfo/Services/SystemInfoService.cs`
- 模型：`UISystemInfo/Models/SystemInfoResponse.cs`
