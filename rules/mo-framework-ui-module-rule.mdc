---
description: 使用MoFramework构建UI模块的规则和指南
globs: *.cs,*.razor
alwaysApply: false
---

# 变量定义

> 变量代表特定上下文的参数，用 `$` 包围。

- `$ModuleName$` - 代表模块名称，必须使用PascalCase。
- `$ModuleUIName$` - UI模块名称，格式为 `$ModuleName$UI`。
- `$UIFolderName$` - UI文件夹名称，格式为 `UI$ModuleName$`。
- `$PageName$` - 页面名称，格式为 `UI$ModuleName$Page`。
- `$RouteURL$` - 页面路由URL，必须使用kebab-case，格式建议为 `/$module-name$-debug` 或 `/$module-name$-manage`。

# MoFramework UI模块规则

## 1. 模块文件结构

### 1.1 创建UI模块类文件
- 文件位置：`MoLibrary.FrameworkUI/Modules/$ModuleUIName$.cs`
- 文件命名：以模块名+UI的格式命名，如 `SignalrUI.cs`
- 类命名：`Module$ModuleUIName$`

### 1.2 创建UI模块文件夹
- 文件夹位置：`MoLibrary.FrameworkUI/$UIFolderName$/`
- 文件夹命名：UI+模块名，如 `UISignalr`
- 子文件夹结构：
  ```
  UI$ModuleName$/
  ├── Components/     # Blazor组件
  ├── Models/         # 数据模型
  └── Services/       # 业务服务
  ```

### 1.3 创建页面文件
- 文件位置：`MoLibrary.FrameworkUI/Pages/$PageName$.razor`
- 文件命名：UI+模块名+Page，如 `UISignalRPage.razor`

## 2. 代码结构规范

### 2.1 UI模块类实现
```csharp
public class Module$ModuleUIName$(Module$ModuleUIName$Option option)
    : MoModuleWithDependencies<Module$ModuleUIName$, Module$ModuleUIName$Option, Module$ModuleUIName$Guide>(option)
{
    public override EMoModules CurModuleEnum()
    {
        return EMoModules.$ModuleUIName$;
    }

    public override void ConfigureServices(IServiceCollection services)
    {
        // 注册相关服务
        services.AddScoped<$ModuleName$Service>();
    }

    public override void ClaimDependencies()
    {
        if (!Option.Disable$ModuleName$Page)
        {
            DependsOnModule<Module$ModuleName$Guide>().Register();
            DependsOnModule<ModuleUICoreGuide>().Register()
                .RegisterUIComponents(p => p.RegisterComponent<$PageName$>(
                    $PageName$.$ModuleName$_DEBUG_URL, 
                    "$ModuleName$调试", 
                    Icons.Material.Filled.Settings, 
                    "系统管理", 
                    addToNav: true, 
                    navOrder: 100));
        }
    }
}
```

### 2.2 页面路由定义
```csharp
@attribute [Route($ModuleName$_DEBUG_URL)]

@code {
    public const string $ModuleName$_DEBUG_URL = "/$route-url$";
}
```

### 2.3 页面依赖注入
```csharp
@using MoLibrary.FrameworkUI.$UIFolderName$.Components
@using MoLibrary.FrameworkUI.$UIFolderName$.Services
@using MoLibrary.FrameworkUI.$UIFolderName$.Models
@inject $ModuleName$Service $ModuleName$Service
```

## 3. 模块化开发要求

### 3.1 组件拆分原则
- **单一职责**：每个组件只负责一个特定功能
- **可复用性**：通用功能抽离为独立组件
- **参数化**：通过参数控制组件行为和显示

### 3.2 组件命名规范
- 组件文件放在 `$UIFolderName$/Components/` 目录下
- 命名格式：`$ModuleName$$FunctionName$.razor`
- 示例：`SignalRConnectionConfig.razor`、`SignalRMessageLog.razor`

### 3.3 服务抽象原则
- 业务逻辑抽离到Service层
- Service文件放在 `$UIFolderName$/Services/` 目录下  
- 命名格式：`$ModuleName$Service.cs`
- 使用`IUIControllerInvoker<Module$ModuleName$UIOption>`进行Controller调用
- 所有服务方法返回值必须不为空，使用`Res<T>`或`Res`类型
- 异常情况必须捕获并返回`Res.Fail`
- 通过依赖注入使用服务

### 3.4 数据模型管理
- 页面相关的数据模型放在 `$UIFolderName$/Models/` 目录下
- 使用强类型模型，避免动态类型
- 模型命名要清晰表达其用途

## 4. 开发最佳实践

### 4.1 代码复用
- 相似功能的组件要抽象出公共基类或接口
- 通用的UI交互逻辑封装成可复用的服务
- 统一的样式和主题使用MudBlazor组件库

### 4.2 性能优化
- 大组件拆分为小组件，减少重渲染范围
- 使用`@key`指令优化列表渲染
- 避免在模板中进行复杂计算

### 4.3 错误处理
- 实现统一的错误处理机制
- 使用ISnackbar显示用户友好的错误信息
- 记录详细的调试日志

### 4.4 Blazor生命周期最佳实践
- **避免在OnInitializedAsync中进行耗时操作**：接口初始化和JavaScript互操作不应放在OnInitializedAsync中，这会导致页面阻塞和空白等待
- **使用OnAfterRenderAsync进行初始化**：将耗时的接口调用和JavaScript互操作放在OnAfterRenderAsync(bool firstRender)中
- **确保只在首次渲染时执行**：使用firstRender参数确保初始化逻辑只在首次渲染时执行一次
- **示例代码**：
  ```csharp
  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
      if (firstRender)
      {
          await LoadDataAsync(); // 耗时的接口调用
          await JSRuntime.InvokeVoidAsync("initializeComponent"); // JavaScript互操作
      }
  }
  ```

## 5. Controller集成模式

### 5.1 Controller开发规范
当需要为UI模块提供API支持时，应遵循以下模式：

#### 5.1.1 Controller位置和命名
- Controller文件位置：`$UIFolderName$/Controllers/Module$ModuleName$Controller.cs`
- Controller命名：`Module$ModuleName$Controller`
- 继承：`MoModuleControllerBase`
- 特性：`[ApiController]`

#### 5.1.2 模块选项配置
UI模块选项必须继承`MoModuleControllerOption`：
```csharp
public class Module$ModuleName$UIOption : MoModuleControllerOption<Module$ModuleName$UI>
{ 
    public bool DisableUI$ModuleName$Page { get; set; }
}
```

#### 5.1.3 Controller注册
在模块的`ClaimDependencies`方法中注册Controller：
```csharp
public override void ClaimDependencies()
{
    if (!Option.DisableUI$ModuleName$Page)
    {
        // 注册Controller依赖
        DependsOnModule<ModuleControllersGuide>().Register()
            .RegisterMoControllers<Module$ModuleName$Controller>(Option);
        
        // 其他依赖注册...
    }
}
```

#### 5.1.4 Controller实现示例
```csharp
[ApiController]
public class Module$ModuleName$Controller : MoModuleControllerBase
{
    [HttpGet("endpoint")]
    public IActionResult GetData()
    {
        try
        {
            var data = // 获取数据逻辑
            return Res.Ok(data).GetResponse(this);
        }
        catch (Exception ex)
        {
            return Res.Fail($"操作失败: {ex.Message}").GetResponse(this);
        }
    }
}
```

#### 5.1.5 响应类型规范
- 必须使用`Res<T>`或`Res`类型作为返回值
- 引用`MoLibrary.Core.Extensions`中的`RESTfulApiExtensions`
- 使用`.GetResponse(this)`方法进行响应封装

### 5.2 调用Controller的服务模式

#### 5.2.1 服务文件位置
- 服务文件：`$UIFolderName$/Services/$ModuleName$Service.cs`
- 用途：封装对自身Controller的HTTP调用

#### 5.2.2 服务实现模式

**统一使用IUIControllerInvoker调用模式**
```csharp
/// <summary>
/// $ModuleName$服务，用于调用自身的Controller
/// </summary>
/// <param name="controllerInvoker">Controller调用器</param>
public class $ModuleName$Service(IUIControllerInvoker<Module$ModuleName$UIOption> controllerInvoker)
{
    /// <summary>
    /// 示例API调用方法
    /// </summary>
    /// <param name="parameter">参数</param>
    /// <returns>返回值不为空，错误时返回Res.Fail</returns>
    public async Task<Res<TResponse>> GetDataAsync(TRequest parameter)
    {
        try
        {
            // 构建API路径，包含查询参数
            var path = "api/endpoint";
            if (parameter != null)
            {
                path += $"?param={parameter}";
            }

            // 使用 IUIControllerInvoker 调用 Controller
            var result = await controllerInvoker.GetAsync<Module$ModuleName$Controller, TResponse>(path);

            // 直接返回 Res 结果，有错误时会自动传递
            return result;
        }
        catch (Exception ex)
        {
            // 异常情况下返回失败结果
            return Res.Fail<TResponse>($"调用失败: {ex.Message}");
        }
    }

    /// <summary>
    /// POST请求示例
    /// </summary>
    /// <param name="request">请求数据</param>
    /// <returns>返回值不为空，错误时返回Res.Fail</returns>
    public async Task<Res<TResponse>> PostDataAsync(TRequest request)
    {
        try
        {
            var result = await controllerInvoker.PostAsync<Module$ModuleName$Controller, TRequest, TResponse>("api/endpoint", request);
            return result;
        }
        catch (Exception ex)
        {
            return Res.Fail<TResponse>($"提交失败: {ex.Message}");
        }
    }
}
```

#### 5.2.3 服务调用规范

**在组件中调用服务的正确方式：**
```csharp
// 在组件中使用服务
@inject $ModuleName$Service $ModuleName$Service

@code {
    private async Task LoadDataAsync()
    {
        // 使用IsFailed方法检查结果并获取数据或错误
        if ((await $ModuleName$Service.GetDataAsync(parameter)).IsFailed(out var error, out var data))
        {
            // 处理错误情况
            Snackbar.Add($"操作失败: {error}", Severity.Error);
            return;
        }

        // 处理成功情况，data不为null
        ProcessData(data);
    }

    private void ProcessData(TResponse data)
    {
        // 处理数据，data保证不为null
        // ...
    }
}
```

**重要规则：**
- 所有服务方法的返回值必须不为空
- 成功时返回`Res.Ok(data)`，失败时返回`Res.Fail(errorMessage)`
- 异常情况必须捕获并返回`Res.Fail`
- 调用方使用`IsFailed(out var error, out var data)`模式检查结果
- 成功时`data`保证不为null，失败时`error`包含错误信息

#### 5.2.4 依赖注入配置
在模块的`ConfigureServices`方法中注册服务：
```csharp
public override void ConfigureServices(IServiceCollection services)
{
    services.AddScoped<$ModuleName$Service>();
}
```

### 5.3 数据模型管理
- 响应模型位置：`$UIFolderName$/Models/`
- 命名约定：`$ModuleName$Response`、`$ModuleName$Request`等
- 与Controller返回的数据结构保持一致

## 6. 示例参考

以UISignalR模块为例：
- 模块文件：`Modules/SignalrUI.cs`
- UI文件夹：`UISignalr/`
- 页面文件：`Pages/UISignalRPage.razor`
- 组件：`UISignalr/Components/SignalRConnectionConfig.razor`等
- 服务：`UISignalr/Services/SignalRService.cs`

以UISystemInfo模块为例（带Controller集成）：
- 模块文件：`Modules/SystemInfoUI.cs`
- UI文件夹：`UISystemInfo/`
- 页面文件：`Pages/UISystemInfoPage.razor`
- Controller：`UISystemInfo/Controllers/ModuleSystemInfoController.cs`
- 服务：`UISystemInfo/Services/SystemInfoService.cs` (使用IUIControllerInvoker模式)
- 模型：`UISystemInfo/Models/SystemInfoResponse.cs`
