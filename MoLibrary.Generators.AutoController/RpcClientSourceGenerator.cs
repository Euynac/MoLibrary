using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using MoLibrary.Generators.AutoController.Generators;
using MoLibrary.Generators.AutoController.Models;

namespace MoLibrary.Generators.AutoController;

/// <summary>
/// Source generator that creates RPC client interfaces and implementations from metadata files.
/// This generator reads .rpc-metadata.json files (generated by API projects) and generates
/// corresponding client code for RPC communication.
/// </summary>
[Generator]
public class RpcClientSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Uncomment to attach debugger during development
        // Debugger.Launch();

        // Extract client configuration from assembly-level attributes
        var clientConfigProvider = context.CompilationProvider
            .Select((compilation, token) => ExtractClientConfiguration(compilation));

        // Create a provider for RPC metadata files from AdditionalFiles
        var metadataFilesProvider = context.AdditionalTextsProvider
            .Where(static file =>
            {
                // Filter only .rpc-metadata.json files
                return file.Path.EndsWith(".rpc-metadata.json");
            })
            .Select((file, token) =>
            {
                var content = file.GetText(token)?.ToString();
                if (string.IsNullOrEmpty(content))
                    return (file.Path, Metadata: (RpcMetadata?)null, Error: "Empty file");

                try
                {
                    var metadata = ParseMetadataJson(content!);
                    return (file.Path, Metadata: metadata, Error: (string?)null);
                }
                catch (Exception ex)
                {
                    return (file.Path, Metadata: (RpcMetadata?)null, Error: ex.Message);
                }
            })
            .Collect();

        // Combine configuration with metadata files
        var combinedProvider = clientConfigProvider.Combine(metadataFilesProvider);

        // Register source output
        context.RegisterSourceOutput(combinedProvider, (spc, data) =>
        {
            var (configInfo, metadataFiles) = data;
            var (hasClientConfig, httpImplType, addGrpc, addHttp, errorMessage) = configInfo;

            // Report configuration error if any
            if (errorMessage != null)
            {
                ReportDiagnostic(spc, DiagnosticSeverity.Error, "RPC_CLIENT_001",
                    "Configuration Error", errorMessage, Location.None);
                return;
            }

            // Skip if no client config attribute found
            if (!hasClientConfig)
            {
                ReportDiagnostic(spc, DiagnosticSeverity.Info, "RPC_CLIENT_002",
                    "No Client Config",
                    "AutoControllerGeneratorClientConfigAttribute not found. Skipping RPC client generation.",
                    Location.None);
                return;
            }

            // Log configuration
            ReportDiagnostic(spc, DiagnosticSeverity.Info, "RPC_CLIENT_003",
                "Client Config Found",
                $"Found AutoControllerGeneratorClientConfigAttribute. AddHttp={addHttp}, AddGrpc={addGrpc}, HttpImplType={httpImplType ?? "default"}",
                Location.None);

            // Process metadata files
            var validMetadata = new List<RpcMetadata>();
            var fileCount = metadataFiles.Length;

            ReportDiagnostic(spc, DiagnosticSeverity.Info, "RPC_CLIENT_004",
                "Metadata Files Found",
                $"Found {fileCount} RPC metadata file(s)",
                Location.None);

            foreach (var (path, metadata, error) in metadataFiles)
            {
                if (error != null)
                {
                    ReportDiagnostic(spc, DiagnosticSeverity.Warning, "RPC_CLIENT_005",
                        "Metadata Parse Error",
                        $"Failed to parse {path}: {error}",
                        Location.None);
                    continue;
                }

                if (metadata != null)
                {
                    validMetadata.Add(metadata);
                    ReportDiagnostic(spc, DiagnosticSeverity.Info, "RPC_CLIENT_006",
                        "Metadata Loaded",
                        $"Loaded metadata for {metadata.DomainName ?? metadata.AssemblyName} with {metadata.Handlers.Count} handler(s)",
                        Location.None);
                }
            }

            // Generate clients if we have valid metadata
            if (validMetadata.Count == 0)
            {
                ReportDiagnostic(spc, DiagnosticSeverity.Info, "RPC_CLIENT_007",
                    "No Valid Metadata",
                    "No valid RPC metadata found. API projects may need to be built first to generate metadata files.",
                    Location.None);
                return;
            }

            // Generate client code for each domain
            if (addHttp)
            {
                GenerateHttpClients(spc, validMetadata, httpImplType ?? "MoLibrary.DomainDrivenDesign.AutoController.MoRpc.MoHttpApi");
            }

            if (addGrpc)
            {
                // TODO: Implement gRPC client generation
                ReportDiagnostic(spc, DiagnosticSeverity.Warning, "RPC_CLIENT_008",
                    "gRPC Not Implemented",
                    "gRPC client generation is not yet implemented",
                    Location.None);
            }
        });
    }

    /// <summary>
    /// Generates HTTP client interfaces and implementations for all domains.
    /// </summary>
    private static void GenerateHttpClients(
        SourceProductionContext context,
        List<RpcMetadata> metadataList,
        string httpImplType)
    {
        foreach (var metadata in metadataList)
        {
            try
            {
                var (interfaceCode, implementationCode) = RpcClientCodeGenerator.GenerateClientForDomain(
                    metadata,
                    httpImplType);

                var domainName = metadata.DomainName ?? metadata.AssemblyName.Replace(".API", "").Replace("Service", "");

                // Add generated files
                context.AddSource($"I{domainName}Api.g.cs", interfaceCode);
                context.AddSource($"{domainName}HttpApi.g.cs", implementationCode);

                ReportDiagnostic(context, DiagnosticSeverity.Info, "RPC_CLIENT_009",
                    "Client Generated",
                    $"Generated RPC client for {domainName} domain",
                    Location.None);
            }
            catch (Exception ex)
            {
                ReportDiagnostic(context, DiagnosticSeverity.Error, "RPC_CLIENT_010",
                    "Generation Error",
                    $"Failed to generate client for {metadata.DomainName}: {ex.Message}",
                    Location.None);
            }
        }
    }

    /// <summary>
    /// Parses RPC metadata from JSON string.
    /// Uses simple regex-based parsing to avoid dependencies.
    /// </summary>
    private static RpcMetadata ParseMetadataJson(string json)
    {
        var metadata = new RpcMetadata();

        // Parse assembly name
        var assemblyNameMatch = Regex.Match(json, @"""AssemblyName""\s*:\s*""([^""]*)""");
        if (assemblyNameMatch.Success)
            metadata.AssemblyName = assemblyNameMatch.Groups[1].Value;

        // Parse domain name
        var domainNameMatch = Regex.Match(json, @"""DomainName""\s*:\s*""([^""]*)""");
        if (domainNameMatch.Success)
            metadata.DomainName = domainNameMatch.Groups[1].Value;

        // Parse route prefix
        var routePrefixMatch = Regex.Match(json, @"""RoutePrefix""\s*:\s*""([^""]*)""");
        if (routePrefixMatch.Success)
            metadata.RoutePrefix = routePrefixMatch.Groups[1].Value;

        // Parse handlers array
        var handlersMatch = Regex.Match(json, @"""Handlers""\s*:\s*\[(.*)\]", RegexOptions.Singleline);
        if (handlersMatch.Success)
        {
            var handlersJson = handlersMatch.Groups[1].Value;
            // Split by handler objects (look for opening braces)
            var handlerMatches = Regex.Matches(handlersJson, @"\{[^}]*\}", RegexOptions.Singleline);

            foreach (Match handlerMatch in handlerMatches)
            {
                var handlerJson = handlerMatch.Value;
                var handler = ParseHandlerMetadata(handlerJson);
                if (handler != null)
                    metadata.Handlers.Add(handler);
            }
        }

        return metadata;
    }

    /// <summary>
    /// Parses a single handler metadata object from JSON.
    /// </summary>
    private static HandlerMetadata? ParseHandlerMetadata(string json)
    {
        try
        {
            var handler = new HandlerMetadata();

            handler.HandlerName = ExtractJsonString(json, "HandlerName") ?? "";
            handler.FullTypeName = ExtractJsonString(json, "FullTypeName") ?? "";
            handler.RequestType = ExtractJsonString(json, "RequestType") ?? "";
            handler.ResponseType = ExtractJsonString(json, "ResponseType") ?? "";
            handler.HttpMethod = ExtractJsonString(json, "HttpMethod") ?? "";
            handler.Route = ExtractJsonString(json, "Route") ?? "";
            handler.Namespace = ExtractJsonString(json, "Namespace") ?? "";
            handler.ClientMethodName = ExtractJsonString(json, "ClientMethodName") ?? "";
            handler.HandlerType = ExtractJsonString(json, "HandlerType") ?? "";

            // Parse tags array
            var tagsMatch = Regex.Match(json, @"""Tags""\s*:\s*\[(.*?)\]");
            if (tagsMatch.Success)
            {
                var tagsJson = tagsMatch.Groups[1].Value;
                var tagMatches = Regex.Matches(tagsJson, @"""([^""]*)""");
                foreach (Match tagMatch in tagMatches)
                {
                    handler.Tags.Add(tagMatch.Groups[1].Value);
                }
            }

            return handler;
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Extracts a string value from a JSON property.
    /// </summary>
    private static string? ExtractJsonString(string json, string propertyName)
    {
        var match = Regex.Match(json, $@"""{propertyName}""\s*:\s*""([^""]*)""");
        return match.Success ? match.Groups[1].Value : null;
    }

    /// <summary>
    /// Extracts the client configuration from assembly-level attributes.
    /// </summary>
    private static (bool HasClientConfig, string? HttpImplType, bool AddGrpc, bool AddHttp, string? ErrorMessage)
        ExtractClientConfiguration(Compilation compilation)
    {
        try
        {
            var assemblyAttributes = compilation.Assembly.GetAttributes();
            AttributeData? clientConfigAttribute = null;

            // Find the AutoControllerGeneratorClientConfigAttribute
            foreach (var attribute in assemblyAttributes)
            {
                if (attribute.AttributeClass?.Name == "AutoControllerGeneratorClientConfigAttribute")
                {
                    clientConfigAttribute = attribute;
                    break;
                }
            }

            if (clientConfigAttribute == null)
            {
                return (false, null, false, false, null);
            }

            // Extract configuration values
            bool addGrpc = false;
            bool addHttp = true;
            string? httpImplType = null;

            foreach (var namedArgument in clientConfigAttribute.NamedArguments)
            {
                switch (namedArgument.Key)
                {
                    case "AddGrpcImplementations":
                        if (namedArgument.Value.Value is bool grpcValue)
                            addGrpc = grpcValue;
                        break;
                    case "AddHttpImplementations":
                        if (namedArgument.Value.Value is bool httpValue)
                            addHttp = httpValue;
                        break;
                    case "HttpImplementationType":
                        if (namedArgument.Value.Value is INamedTypeSymbol typeSymbol)
                            httpImplType = typeSymbol.ToDisplayString();
                        break;
                }
            }

            return (true, httpImplType, addGrpc, addHttp, null);
        }
        catch (Exception ex)
        {
            return (false, null, false, false, $"Failed to extract client configuration: {ex.Message}");
        }
    }

    /// <summary>
    /// Helper method to report diagnostics with consistent formatting.
    /// </summary>
    private static void ReportDiagnostic(
        SourceProductionContext context,
        DiagnosticSeverity severity,
        string id,
        string title,
        string message,
        Location location)
    {
        var descriptor = new DiagnosticDescriptor(
            id: id,
            title: title,
            messageFormat: message,
            category: "RpcClientGenerator",
            defaultSeverity: severity,
            isEnabledByDefault: true);

        context.ReportDiagnostic(Diagnostic.Create(descriptor, location));
    }
}
