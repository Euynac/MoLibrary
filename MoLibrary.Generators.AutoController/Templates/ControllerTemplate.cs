using System.Collections.Generic;
using System.Linq;
using System.Text;
using MoLibrary.Generators.AutoController.Constants;
using MoLibrary.Generators.AutoController.Helpers;
using MoLibrary.Generators.AutoController.Models;

namespace MoLibrary.Generators.AutoController.Templates;

internal static class ControllerTemplate
{
    /// <summary>
    /// Generates the complete controller class source code.
    /// </summary>
    /// <param name="controllerName">The name of the controller class</param>
    /// <param name="route">The base route for the controller</param>
    /// <param name="tags">The collection of tags for the controller</param>
    /// <param name="usingDirectives">The using directives to include</param>
    /// <param name="methods">The method definitions</param>
    /// <returns>The complete controller source code</returns>
    public static string GenerateControllerClass(
        string controllerName,
        string route,
        IEnumerable<string> tags,
        string usingDirectives,
        string methods)
    {
        var tagAttributeContent = GenerateTagAttribute(tags);

        return $$"""
            {{GeneratorConstants.Templates.AutoGeneratedComment}}
            {{usingDirectives}}

            namespace {{GeneratorConstants.Namespaces.GeneratedControllers}}
            {
                [Route("{{route}}")]
                [{{GeneratorConstants.AttributeNames.ApiController}}]{{tagAttributeContent}}
                public class {{controllerName}}(IMediator mediator) : {{GeneratorConstants.ClassNames.ControllerBase}}
                {
            {{methods}}
                }
            }
            """;
    }

    /// <summary>
    /// Generates a single controller method.
    /// </summary>
    /// <param name="candidate">The handler candidate containing method information</param>
    /// <returns>The method source code</returns>
    public static string GenerateMethod(HandlerCandidate candidate)
    {
        var bindingAttribute = AttributeHelper.DetermineBindingAttribute(
            candidate.HttpMethodAttribute, 
            candidate.HasFromFormAttribute);

        var documentationComment = string.IsNullOrWhiteSpace(candidate.DocumentationComment) 
            ? string.Empty 
            : $"{candidate.DocumentationComment}\n";

        return $$"""
        {{documentationComment}}        [{{candidate.HttpMethodAttribute}}("{{candidate.HttpMethodRoute}}")]
                [{{GeneratorConstants.AttributeNames.ProducesResponseType}}((int) HttpStatusCode.Accepted)]
                [{{GeneratorConstants.AttributeNames.ProducesResponseType}}((int) HttpStatusCode.BadRequest)]
                [{{GeneratorConstants.AttributeNames.ProducesResponseType}}(typeof({{string.Format(GeneratorConstants.ResponseTypes.GenericResponseTemplate, candidate.ResponseType)}}), (int) HttpStatusCode.OK)]
                public async Task<object> {{candidate.MethodName}}(
                    [{{bindingAttribute}}] {{candidate.RequestType}} dto)
                {
                    return await mediator.Send(dto).GetResponse(this);
                }

        """;
    }

    /// <summary>
    /// Generates all methods for a collection of candidates.
    /// </summary>
    /// <param name="candidates">The collection of handler candidates</param>
    /// <returns>The concatenated method source code</returns>
    public static string GenerateAllMethods(IEnumerable<HandlerCandidate> candidates)
    {
        var methodsBuilder = new StringBuilder();

        foreach (var candidate in candidates)
        {
            methodsBuilder.Append(GenerateMethod(candidate));
        }

        return methodsBuilder.ToString();
    }

    /// <summary>
    /// Generates the Tags attribute content if tags are provided.
    /// </summary>
    /// <param name="tags">The collection of tags</param>
    /// <returns>The Tags attribute content or empty string</returns>
    private static string GenerateTagAttribute(IEnumerable<string> tags)
    {
        var tagContent = string.Join(", ", tags.Select(tag => $"\"{tag}\""));
        
        return string.IsNullOrEmpty(tagContent) 
            ? string.Empty 
            : $"\n[{GeneratorConstants.AttributeNames.Tags}({tagContent})]";
    }

    /// <summary>
    /// Generates the using directives section.
    /// </summary>
    /// <param name="usingStatements">The collection of using statements</param>
    /// <returns>The formatted using directives</returns>
    public static string GenerateUsingDirectives(IEnumerable<string> usingStatements)
    {
        var orderedUsings = usingStatements
            .Distinct()
            .OrderBy(u => u)
            .Select(u => $"using {u};");

        return string.Join("\n", orderedUsings);
    }
}