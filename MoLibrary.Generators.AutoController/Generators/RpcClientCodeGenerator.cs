using System.Collections.Generic;
using System.Linq;
using System.Text;
using MoLibrary.Generators.AutoController.Models;

namespace MoLibrary.Generators.AutoController.Generators;

/// <summary>
/// Generates RPC client interfaces and implementations from metadata.
/// </summary>
internal static class RpcClientCodeGenerator
{
    /// <summary>
    /// Generates client code for a single domain (assembly).
    /// Returns a tuple of (interfaceCode, implementationCode).
    /// </summary>
    public static (string InterfaceCode, string ImplementationCode) GenerateClientForDomain(
        RpcMetadata metadata,
        string httpImplType)
    {
        var domainName = metadata.DomainName ?? metadata.AssemblyName.Replace(".API", "").Replace("Service", "");
        var interfaceName = $"I{domainName}Api";
        var implementationName = $"{domainName}HttpApi";

        // Generate interface
        var interfaceCode = GenerateClientInterface(metadata, interfaceName);

        // Generate implementation
        var implementationCode = GenerateClientImplementation(metadata, interfaceName, implementationName, httpImplType);

        return (interfaceCode, implementationCode);
    }

    /// <summary>
    /// Generates the client interface code.
    /// </summary>
    private static string GenerateClientInterface(RpcMetadata metadata, string interfaceName)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file is generated by RpcClientSourceGenerator");
        sb.AppendLine();

        // Usings
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        // Extract unique namespaces from request/response types
        var namespaces = metadata.Handlers
            .SelectMany(h => new[] { h.RequestType, h.ResponseType })
            .Select(ExtractNamespace)
            .Where(ns => !string.IsNullOrEmpty(ns))
            .Distinct()
            .OrderBy(ns => ns);

        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();

        // Namespace
        var clientNamespace = "ProtocolPlatform.RpcClients";
        sb.AppendLine($"namespace {clientNamespace};");
        sb.AppendLine();

        // Interface declaration
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// RPC client interface for {metadata.DomainName} domain");
        sb.AppendLine($"/// Generated from assembly: {metadata.AssemblyName}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public interface {interfaceName}");
        sb.AppendLine("{");

        // Generate interface methods
        foreach (var handler in metadata.Handlers)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {handler.ClientMethodName}");
            sb.AppendLine($"    /// Handler: {handler.HandlerName}");
            sb.AppendLine($"    /// Route: {handler.HttpMethod} {handler.Route}");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    Task<{handler.ResponseType}> {handler.ClientMethodName}({handler.RequestType} request);");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates the client implementation code.
    /// </summary>
    private static string GenerateClientImplementation(
        RpcMetadata metadata,
        string interfaceName,
        string implementationName,
        string httpImplType)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file is generated by RpcClientSourceGenerator");
        sb.AppendLine();

        // Usings
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine("using System.Net.Http.Json;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using MoLibrary.DependencyInjection.AppInterfaces;");

        // Add using for the base class
        var baseClassNamespace = ExtractNamespace(httpImplType);
        if (!string.IsNullOrEmpty(baseClassNamespace))
        {
            sb.AppendLine($"using {baseClassNamespace};");
        }

        sb.AppendLine();

        // Extract unique namespaces from request/response types
        var namespaces = metadata.Handlers
            .SelectMany(h => new[] { h.RequestType, h.ResponseType })
            .Select(ExtractNamespace)
            .Where(ns => !string.IsNullOrEmpty(ns))
            .Distinct()
            .OrderBy(ns => ns);

        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();

        // Namespace
        var clientNamespace = "ProtocolPlatform.RpcClients";
        sb.AppendLine($"namespace {clientNamespace};");
        sb.AppendLine();

        // Extract simple base class name
        var baseClassName = ExtractSimpleTypeName(httpImplType);

        // Implementation declaration
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// HTTP RPC client implementation for {metadata.DomainName} domain");
        sb.AppendLine($"/// Generated from assembly: {metadata.AssemblyName}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public class {implementationName} : {baseClassName}, {interfaceName}");
        sb.AppendLine("{");

        // Constructor
        sb.AppendLine($"    public {implementationName}(IMoServiceProvider provider, HttpClient httpClient)");
        sb.AppendLine($"        : base(provider, httpClient)");
        sb.AppendLine("    {");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate implementation methods
        foreach (var handler in metadata.Handlers)
        {
            GenerateClientMethod(sb, handler);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates a single client method implementation.
    /// </summary>
    private static void GenerateClientMethod(StringBuilder sb, HandlerMetadata handler)
    {
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// {handler.ClientMethodName}");
        sb.AppendLine($"    /// Handler: {handler.HandlerName}");
        sb.AppendLine($"    /// Route: {handler.HttpMethod} {handler.Route}");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public async Task<{handler.ResponseType}> {handler.ClientMethodName}({handler.RequestType} request)");
        sb.AppendLine("    {");

        // Generate HTTP call based on method type
        var httpMethod = handler.HttpMethod.ToUpperInvariant();
        var route = handler.Route;

        switch (httpMethod)
        {
            case "POST":
                sb.AppendLine($"        var response = await HttpClient.PostAsJsonAsync(\"{route}\", request);");
                break;
            case "GET":
                // For GET, we might need to serialize request as query string
                // For now, assume GET requests don't need body
                sb.AppendLine($"        var response = await HttpClient.GetAsync(\"{route}\");");
                break;
            case "PUT":
                sb.AppendLine($"        var response = await HttpClient.PutAsJsonAsync(\"{route}\", request);");
                break;
            case "DELETE":
                sb.AppendLine($"        var response = await HttpClient.DeleteAsync(\"{route}\");");
                break;
            default:
                sb.AppendLine($"        var response = await HttpClient.PostAsJsonAsync(\"{route}\", request);");
                break;
        }

        sb.AppendLine("        response.EnsureSuccessStatusCode();");
        sb.AppendLine($"        return await response.Content.ReadFromJsonAsync<{handler.ResponseType}>() ");
        sb.AppendLine($"            ?? throw new System.InvalidOperationException(\"Failed to deserialize response\");");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Extracts the namespace from a fully qualified type name.
    /// </summary>
    private static string? ExtractNamespace(string fullTypeName)
    {
        if (string.IsNullOrEmpty(fullTypeName))
            return null;

        // Remove generic arguments
        var typeWithoutGenerics = fullTypeName.Split('<')[0];

        var lastDot = typeWithoutGenerics.LastIndexOf('.');
        return lastDot > 0 ? typeWithoutGenerics.Substring(0, lastDot) : null;
    }

    /// <summary>
    /// Extracts the simple type name from a fully qualified type name.
    /// </summary>
    private static string ExtractSimpleTypeName(string fullTypeName)
    {
        if (string.IsNullOrEmpty(fullTypeName))
            return "MoHttpApi"; // Default fallback

        // Remove generic arguments if any
        var typeWithoutGenerics = fullTypeName.Split('<')[0];

        var lastDot = typeWithoutGenerics.LastIndexOf('.');
        return lastDot >= 0 ? typeWithoutGenerics.Substring(lastDot + 1) : typeWithoutGenerics;
    }
}
