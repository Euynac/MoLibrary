@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@typeparam TItem
@inject IJSRuntime JSRuntime

@if (IsRootMenu)
{
    <script src="_content/MoLibrary.UI/js/context-menu.js"></script>
}

<div @ref="_contextMenuRef" style="position: fixed; z-index: @ZIndex; display: @(Visible ? "block" : "none"); left: @(_x)px; top: @(_y)px;">
    @if (_positionCalculated && Visible && Items != null && Items.Any())
    {
        <MudPaper Width="@(_menuWidth+"px")" Elevation="8" Class="mo-context-menu">
            <MudList T="string" Dense="true" Class="pa-1" Style="width: 100%">
                @foreach (var item in Items)
                {
                    @if (item.IsDivider)
                    {
                        <MudDivider Class="my-1" />
                    }
                    else
                    {
                        <MudListItem T="string" 
                                     Class="@($"mo-context-menu-item {(item.Disabled ? "disabled" : "")} {(item == _hoveredItem ? "hovered" : "")}")"
                                     Style="width: 100%"
                                     Disabled="@item.Disabled"
                                     OnClick="@(() => HandleItemClick(item))"
                                     @onmouseenter="@((MouseEventArgs e) => OnItemMouseEnter(item, e))"
                                     @onmouseleave="@(() => OnItemMouseLeave(item))">
                            <div class="d-flex align-center" style="width: 100%; position: relative;">
                                @if (!string.IsNullOrEmpty(item.Icon))
                                {
                                    <MudIcon Icon="@item.Icon" Size="Size.Small" Class="mo-menu-icon" />
                                }
                                else
                                {
                                    <div class="mo-menu-icon-placeholder"></div>
                                }
                                <MudText Typo="Typo.body2" Class="mo-menu-text">@item.Text</MudText>
                                @if (item.HasSubMenu)
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.ChevronRight" Size="Size.Small" Class="mo-menu-arrow" />
                                }
                                else if (!string.IsNullOrEmpty(item.ShortcutText))
                                {
                                    <MudText Typo="Typo.caption" Class="mo-menu-shortcut">@item.ShortcutText</MudText>
                                }
                            </div>
                        </MudListItem>
                    }
                }
            </MudList>
        </MudPaper>
    }
</div>

<!-- 子菜单 -->
@if (_subMenuVisible && _hoveredItem?.HasSubMenu == true && _hoveredItem.SubItems?.Any() == true)
{
    <MoContextMenu TItem="TItem" 
                   Items="@_hoveredItem.SubItems" 
                   Visible="_subMenuVisible"
                   InitialX="_subMenuX" 
                   InitialY="_subMenuY"
                   ZIndex="@(ZIndex + 1)"
                   ContextItem="@ContextItem"
                   IsRootMenu="false"
                   OnItemClick="@OnSubItemClick"
                   OnClose="@OnSubMenuClose" />
}

<!-- 只有根菜单才渲染透明遮罩 -->
@if (IsRootMenu && Visible)
{
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: @(ZIndex - 1);" 
         @onclick="CloseMenu"
         @oncontextmenu:preventDefault="true"></div>
}

@implements IDisposable

@code {
    [Parameter] public List<ContextMenuItem<TItem>> Items { get; set; } = new();
    [Parameter] public bool Visible { get; set; } = false;
    [Parameter] public double InitialX { get; set; } = 0;
    [Parameter] public double InitialY { get; set; } = 0;
    [Parameter] public int ZIndex { get; set; } = 1300;
    [Parameter] public bool IsRootMenu { get; set; } = true;
    [Parameter] public TItem? ContextItem { get; set; }
    [Parameter] public EventCallback<ContextMenuItem<TItem>> OnItemClick { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    
    private ElementReference _contextMenuRef;
    private ContextMenuItem<TItem>? _hoveredItem;
    private bool _subMenuVisible = false;
    private double _subMenuX = 0;
    private double _subMenuY = 0;
    private double _menuWidth = 220;
    private double _x = 0;
    private double _y = 0;
    private bool _positionCalculated = false;
    private Timer? _hideSubMenuTimer;
    private Timer? _showSubMenuTimer;

    protected override async Task OnParametersSetAsync()
    {
        if (!_positionCalculated)
        {
            _x = InitialX;
            _y = InitialY;
            
            if (Visible)
            {
                await CalculateMenuWidth();
                await AdjustPosition();
                _positionCalculated = true;
            }
        }
        else if (!Visible)
        {
            // Reset position calculation flag when menu is hidden
            _positionCalculated = false;
        }
    }

    private async Task HandleItemClick(ContextMenuItem<TItem> item)
    {
        if (item.Disabled || item.HasSubMenu) return;
        
        // 执行项目的点击事件
        if (item.OnClick != null)
        {
            await item.OnClick.Invoke(ContextItem);
        }
        
        // 触发外部点击事件
        await OnItemClick.InvokeAsync(item);
        
        // 关闭菜单
        await CloseMenu();
    }
    
    private async Task OnSubItemClick(ContextMenuItem<TItem> item)
    {
        if (item.Disabled || item.HasSubMenu) return;
        
        // 执行项目的点击事件
        if (item.OnClick != null)
        {
            await item.OnClick.Invoke(ContextItem);
        }
        
        // 触发外部点击事件
        await OnItemClick.InvokeAsync(item);
        
        // 关闭所有菜单
        await CloseMenu();
    }
    
    private void OnItemMouseEnter(ContextMenuItem<TItem> item, MouseEventArgs e)
    {
        // 取消所有定时器
        _hideSubMenuTimer?.Dispose();
        _showSubMenuTimer?.Dispose();
        
        if (_hoveredItem != item)
        {
            _hoveredItem = item;
            StateHasChanged();
            
            if (item.HasSubMenu)
            {
                // 延迟显示子菜单
                _showSubMenuTimer = new Timer(_ => 
                {
                    if (_hoveredItem == item)
                    {
                        InvokeAsync(() => ShowSubMenu(item, e));
                    }
                }, null, 150, Timeout.Infinite);
            }
            else
            {
                // 隐藏子菜单
                _subMenuVisible = false;
                StateHasChanged();
            }
        }
    }
    
    private void OnItemMouseLeave(ContextMenuItem<TItem> item)
    {
        _showSubMenuTimer?.Dispose();
        
        if (item.HasSubMenu)
        {
            // 延迟隐藏子菜单
            _hideSubMenuTimer = new Timer(_ => 
            {
                InvokeAsync(() => 
                {
                    _subMenuVisible = false;
                    StateHasChanged();
                });
            }, null, 200, Timeout.Infinite);
        }
    }
    
    private void ShowSubMenu(ContextMenuItem<TItem> item, MouseEventArgs e)
    {
        if (item.HasSubMenu && item.SubItems?.Any() == true)
        {
            // 计算子菜单位置
            _subMenuX = _x + _menuWidth;
            _subMenuY = _y + e.OffsetY - 10;
            
            _subMenuVisible = true;
            StateHasChanged();
        }
    }
    
    private void OnSubMenuClose()
    {
        _subMenuVisible = false;
        StateHasChanged();
    }
    
    private async Task CloseMenu()
    {
        await OnClose.InvokeAsync();
    }
    
    private async Task CalculateMenuWidth()
    {
        if (!IsRootMenu) return;
        
        try
        {
            var menuItems = Items.Select(item => new 
            {
                text = item.Text,
                shortcutText = item.ShortcutText,
                hasSubMenu = item.HasSubMenu,
                isDivider = item.IsDivider
            }).ToArray();
            
            _menuWidth = await JSRuntime.InvokeAsync<double>("MoContextMenu.calculateMenuWidth", (object)menuItems);
        }
        catch
        {
            _menuWidth = 220;
        }
    }

    private async Task AdjustPosition()
    {
        try
        {
            var windowSize = await JSRuntime.InvokeAsync<WindowSize>("MoContextMenu.getWindowSize");
            var menuHeight = Items.Count(i => !i.IsDivider) * 40 + Items.Count(i => i.IsDivider) * 12 + 20;
            var margin = 10;
            
            // 调整位置确保菜单在视窗内
            if (_x + _menuWidth > windowSize.Width)
            {
                _x = Math.Max(margin, windowSize.Width - _menuWidth - margin);
            }
            
            if (_y + menuHeight > windowSize.Height)
            {
                _y = Math.Max(margin, windowSize.Height - menuHeight - margin);
            }
            
            _x = Math.Max(margin, _x);
            _y = Math.Max(margin, _y);
            
            StateHasChanged();
        }
        catch
        {
            // 忽略JS调用失败
        }
    }
    
    private class WindowSize
    {
        public int Width { get; set; }
        public int Height { get; set; }
    }
    
    public void Dispose()
    {
        _hideSubMenuTimer?.Dispose();
        _showSubMenuTimer?.Dispose();
    }
}